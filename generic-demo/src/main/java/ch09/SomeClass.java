package ch09;

class SomeClass<T> {
    //约束3：不能定义静态化的泛型类型变量与方法，这与声明静态泛型方法不是一个意思，见ch03中SomeClass的静态方法
    // 理由是T只是一个占位符，确定了真正的类型后才能正确使用，而确定真正类型的时机是在通常是在类实例化时，
    //而这个静态的字段与方法在使用时，类的实例化可能压根就没有进行，那么此时是无法知道T到底是个什么类型的，所以不允许这样写

  /*  static  T t;
    public static  T m(){
        return t;
    }*/
    //约束2：类型参数不能实例化
    public void m() {
        // T t  = new T();
    }
}
