# 说明

- 此框架教学用
- 尽量接近spring mvc，也会参考asp.net mvc与struts，比如命名尽量一样
- 暂不考虑线程安全性(*)
- 尽量体现框架的灵活性

# 功能目标

- HandlerMapping
- HandlerAdapter
- ViewResult
- HandlerInterceptor与HandlerExecutionChain
- HandlerMethodArgumentResolver
- HandlerExceptionResolver
- 静态资源处理（Default servlet）
- 文件上传下载
- cors

# DispatcherServlet

前端总控器也叫前端控制器

> response.sendError(HttpServletResponse.SC_NOT_FOUND);

# HandlerMapping

Handler就是后端控制器，由用户编写，真正负责请求的处理

什么是一个Handler完全由HandlerMapping去决定，去查找，框架并不限定，比如下面这些都可以认为是一个Handler

- 普通的类
- 实现了某个接口的类
- 添加了某个注解的类
- 以某个名字结尾的类

这里简单实现url到类名的一个查找逻辑

## 类扫描



# HandlerAdapter



## HttpRequestHandler

## HttpRequestHandlerAdapter



# ViewResult

## ForwardResult

## RedirectResult

## JsonResult

## DefaultResult

## StreamResult



# RequestMappingHandlerMapping



## RequestMapping注解

注解只修饰在方法上，暂不考虑修饰在类上的情况



# RequestMappingHandlerAdapter

## HandlerMethodArgumentResolver



实现以下功能

- 简单类型，比如string，int等，利用RequestParam注解指定名字
- 简单类型的数组，比如int[] ，利用RequestParam注解指定名字
- 复杂类型，一个bean，利用Model注解
- servlet相关API类型，比如HttpServletRequest，HttpSession，HttpServletResponse，ServletContext

### RequestParam

除非打开parameters编译选项，否则jdk8中普通的反射api是没有办法获取参数名的



> org.springframework.core.convert.TypeDescriptor中有一些有用的工具方法，比如isPrimitive，isArray等
>
> org.springframework.core.DefaultParameterNameDiscoverer 此类可以用来解析参数名

### ServletRequestMethodArgumentResolver



### RequestParamMethodArgumentResolver

解析RequestParam注解



### ModelMethodArgumentResolver

解析Model注解

# 上下文对象

## MvcContext

从此类中只读可以获取所有的HandlerMapping(mappings),HandlerAdapters(adapters),handler的方法的参数解析器（argumentResolvers),异常解析器（exceptionResolvers)

### 只读集合



## HandlerContext

​	此类是一个线程安全的请求上下文对象，记录每次请求的相关对象，比如request与response，以便在任意地方都可以方便的获取这些对象，比如在ViewResult里

```java
public class ActionContext {

	public static final String REQUEST = "edu.cj.request";
	public static final String RESPONSE = "edu.cj.response";
	public static final String SESSION = "edu.cj.session";
	public static final String APPLICATION = "edu.cj.application";
	public static final String PARAMETERS = "edu.cj.parameters";
	public static final String VALUESTACK = "edu.cj.valuestack";

	private Map<String, Object> context;
	public static ThreadLocal<ActionContext> actionContext = new ThreadLocal<ActionContext>();

	//action构造函数
	public ActionContext(HttpServletRequest request, HttpServletResponse response, Object action) {
		context = new HashMap<String, Object>();
		// 准备域
		// request
		context.put(REQUEST, request);
		// response
		context.put(RESPONSE, response);
		// session
		context.put(SESSION, request.getSession());
		// application
		context.put(APPLICATION, request.getSession().getServletContext());
		// parameters
		context.put(PARAMETERS, request.getParameterMap());

		// valuestack,暂时值栈只在ParametersIntercepter中有用。
		ValueStack vs = new ValueStack();
		// 将action压入栈顶
		vs.push(action);
		// 将ValueStack放入request域中
		request.setAttribute(VALUESTACK, vs);
		// 将ValueStack放入context域中
		context.put(VALUESTACK, vs);


		// 把创建好的ActionContext对象放入到threadlocal中
		actionContext.set(this);
	}

	/**
	 * @return 当前线程对应的ActionContext对象
	 */
	public static ActionContext getContext() {
		return actionContext.get();
	}

	public HttpServletRequest getRequest() {
		return (HttpServletRequest) context.get(REQUEST);
	}

	public HttpServletResponse getResponse() {
		return (HttpServletResponse) context.get(RESPONSE);
	}

	public HttpSession getSession() {
		return (HttpSession) context.get(SESSION);
	}

	public ServletContext getApplication() {
		return (ServletContext) context.get(APPLICATION);
	}

	public Map<String, String[]> getParams() {
		return (Map<String, String[]>) context.get(PARAMETERS);
	}

	public ValueStack getValueStack() {
		return (ValueStack) context.get(VALUESTACK);
	}

}
```

# 静态资源处理

## DefaultServletHttpRequestHandler

# 文件处理

## 上传

### MultipartFile



> 参见spring的RequestParamMethodArgumentResolver以及MultipartResolutionDelegate

### StandardMultipartFile

spring的FileCopyUtils与StreamUtils可以直接复制过来使用，比较简单

## 下载（FileResult)

`Content-Disposition`

> HttpHeaders.CONTENT_DISPOSITION

# Cors



# 框架扩展

可以从以下几个方面扩展框架

- 添加自己的HandlerMapping
- 添加自己的HandlerAdapter
- 添加自己的HandlerMethodArgumentResolver
- 添加自己的HandlerExceptionResolver
- 添加自己的ViewResult

## 对象注册

可以在DispatcherServlet的初始化配置中注册，也可以利用Servlet的监听器注册这些扩展组件

# 附录

## classgraph

https://mvnrepository.com/artifact/io.github.classgraph/classgraph，在https://www.baeldung.com/classgraph有一个简单的入门教程

The cool thing is that **Classgraph is fast, as it works on the byte-code level**, meaning the inspected classes are not loaded to the JVM, and it doesn't use reflection for processing.

When we want to instantiate found classes, it's very important to do that not via *Class.forName,* but by using the library method *ClassInfo.loadClass*.

The reason is that Classgraph uses its own class loader to load classes from some JAR files. So, if we use *Class.forName*, the same class might be loaded more than once by different class loaders, and this might lead to non-trivial bugs.

类似的工具有Reflections，基本使用见https://www.baeldung.com/reflections-library

```xml
<dependency>
    <groupId>org.reflections</groupId>
    <artifactId>reflections</artifactId>
    <version>0.9.11</version>
</dependency>
```



## javasist获取方法参数名

https://www.cnblogs.com/cccy0/p/13691494.html

```java
private static List<String> getParamNames(String methodName, Class<?> clazz) {
        List<String> paramNames = new ArrayList<>();
        ClassPool pool = ClassPool.getDefault();
        try {
            CtClass ctClass = pool.getCtClass(clazz.getName());
            CtMethod ctMethod = ctClass.getDeclaredMethod(methodName);
            // 使用javassist的反射方法的参数名
            javassist.bytecode.MethodInfo methodInfo = ctMethod.getMethodInfo();
            CodeAttribute codeAttribute = methodInfo.getCodeAttribute();
            LocalVariableAttribute attr = (LocalVariableAttribute) codeAttribute.getAttribute(LocalVariableAttribute.tag);
            if (attr != null) {
                int len = ctMethod.getParameterTypes().length;
                // 非静态的成员函数的第一个参数是this
                int pos = Modifier.isStatic(ctMethod.getModifiers()) ? 0 : 1;
                for (int i = 0; i < len; i++) {
                    paramNames.add(attr.variableName(i + pos));
                }

            }
            return paramNames;
        } catch (NotFoundException e) {
            e.printStackTrace();
            return null;
        }
    }
```



> spring中的MethodParameter与TypeDescriptor可以了解一下

## 泛型解析

TODO:见`ResolvableType.forMethodParameter(methodParam).asCollection().resolveGeneric()`

具体应用是在RequestParamMethodArgumentResolver类的supportsParameter方法中解析方法参数是否是一个MultipartFile集合时用到，可以去了解一下
